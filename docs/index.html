<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Sable Chum Map</title>
    <style>
      @import url("https://fonts.cdnfonts.com/css/century-schoolbook");
      body {
        margin: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        height: 100vh;
        background-color: #333;
        font-family: "Century Schoolbook", serif;
        color: white;
      }

      #counter-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        padding: 10px;
        position: relative;
      }

      #reset-btn {
        font-size: 18px;
        font-family: inherit;
        padding: 5px 10px;
        margin: 10px;
        background-color: #555;
        color: white;
        border: none;
        cursor: pointer;
        position: absolute;
      }

      #reset-btn:hover {
        background-color: #777;
      }

      #counter {
        font-size: 24px;
        margin: 0 auto; /* Center the counter */
        text-align: center;
        flex-grow: 1;
      }

      #map-container {
        position: relative;
        width: 100vw;
        height: calc(100vh - 40px); /* Adjusting for counter height */
        overflow: hidden;
        cursor: grab;
      }

      #map {
        display: block;
        transform-origin: top left;
        user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .collectible {
        position: absolute;
        fill: currentColor;
        stroke: currentColor;
        width: 50px;
        height: 32px;
        left: 0px;
        top: 0px;
      }

      .collected {
        filter: grayscale(100%) brightness(0.67);
      }

      .collectible:hover {
        cursor: pointer;
        filter: drop-shadow(0 0 5px #cccc33) drop-shadow(0 0 10px #cccc33);
      }

      .collected:hover {
        filter: drop-shadow(0px 0px 5px white) drop-shadow(0px 0px 10px white)
          drop-shadow(0px 0px 15px white) grayscale(100%) brightness(0.67);
      }
    </style>
  </head>
  <body>
    <div id="counter-container">
      <button id="reset-btn">Reset View</button>
      <div id="counter">0/165</div>
    </div>
    <div id="map-container">
      <img
        id="map"
        src="Sable-Chum-Map-90.webp"
        alt="Game Map"
        draggable="false"
        loading="lazy"
      />
    </div>
    <script>
      const collectibles = [];

      const mapContainer = document.getElementById("map-container");
      const map = document.getElementById("map");
      const counter = document.getElementById("counter");
      const reset = document.getElementById("reset-btn");

      let scale = 1;
      let originX = 0;
      let originY = 0;
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let wasDragging = false;

      function updateTransform() {
        map.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;

        document.querySelectorAll(".collectible").forEach((marker, index) => {
          const coord = collectibles[index];

          const transformedX = (coord.x - 6) * scale + originX - 25;
          const transformedY = (coord.y + 5) * scale + originY - 16;

          const markerScale = Math.max(scale, 32 / marker.offsetWidth);

          marker.style.transform = `translate(${transformedX}px, ${transformedY}px) scale(${markerScale})`;
        });

        saveStateToLocalStorage();
      }

      function saveStateToLocalStorage() {
        const state = {
          scale,
          originX,
          originY,
        };
        localStorage.setItem("mapState", JSON.stringify(state));
      }

      function loadStateFromLocalStorage() {
        const savedState = JSON.parse(localStorage.getItem("mapState"));
        if (savedState) {
          scale = savedState.scale;
          originX = savedState.originX;
          originY = savedState.originY;
        } else {
          fitMapToContainer();
        }
      }

      function fitMapToContainer() {
        const containerRect = mapContainer.getBoundingClientRect();
        const naturalWidth = map.naturalWidth;
        const naturalHeight = map.naturalHeight;

        const scaleX = containerRect.width / naturalWidth;
        const scaleY = containerRect.height / naturalHeight;

        scale = Math.min(scaleX, scaleY);

        originX = (containerRect.width - naturalWidth * scale) / 2;
        originY = (containerRect.height - naturalHeight * scale) / 2;
      }

      function loadCollectibles() {
        const collected = JSON.parse(localStorage.getItem("collected") || "[]");

        collectibles.forEach((coord, index) => {
          const featherImg = document.createElement("img");
          featherImg.classList.add("collectible");
          featherImg.src = "feather.svg";
          featherImg.draggable = false;

          if (collected.includes(index)) {
            featherImg.classList.add("collected");
          }

          featherImg.addEventListener("click", () => {
            toggleCollectible(index, featherImg);
          });

          mapContainer.appendChild(featherImg);
        });

        updateCounter();
      }

      function toggleCollectible(index, featherImg) {
        if (!wasDragging) {
          let collected = JSON.parse(localStorage.getItem("collected") || "[]");

          if (collected.includes(index)) {
            collected = collected.filter((i) => i !== index);
            featherImg.classList.remove("collected");
          } else {
            collected.push(index);
            featherImg.classList.add("collected");
          }

          localStorage.setItem("collected", JSON.stringify(collected));

          updateCounter();
        }
      }

      function updateCounter() {
        const collected = JSON.parse(localStorage.getItem("collected") || "[]");
        counter.textContent = `${collected.length}/${collectibles.length}`;
      }

      map.addEventListener("dragstart", (event) => event.preventDefault());

      mapContainer.addEventListener("wheel", (event) => {
        event.preventDefault();

        const rect = map.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / scale;
        const mouseY = (event.clientY - rect.top) / scale;

        const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
        const newScale = scale * zoomFactor;

        originX = mouseX * (scale - newScale) + originX;
        originY = mouseY * (scale - newScale) + originY;

        scale = newScale;

        updateTransform();
      });

      mapContainer.addEventListener("mousedown", (event) => {
        isDragging = true;
        wasDragging = false;
        startX = event.clientX - originX;
        startY = event.clientY - originY;
        mapContainer.style.cursor = "grabbing";
      });

      mapContainer.addEventListener("mousemove", (event) => {
        if (isDragging) {
          originX = event.clientX - startX;
          originY = event.clientY - startY;
          updateTransform();
          wasDragging = true;
        }
      });

      mapContainer.addEventListener("mouseup", () => {
        isDragging = false;
        mapContainer.style.cursor = "grab";
      });

      mapContainer.addEventListener("mouseleave", () => {
        isDragging = false;
        mapContainer.style.cursor = "grab";
      });

      counter.addEventListener("click", () => {
        fitMapToContainer();
        updateTransform();
      });

      reset.addEventListener("click", () => {
        fitMapToContainer();
        updateTransform();
      });

      window.addEventListener("load", () => {
        loadStateFromLocalStorage();
        fetch("chums.json")
          .then((response) => response.json())
          .then((data) => {
            collectibles.push(...data);
            loadCollectibles();
            updateTransform();
          });
      });
    </script>
  </body>
</html>
